<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game-Axolotl Build</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .info-button {
            position: absolute;
            top: 0;
            right: 0;
            margin-right: 20px;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .info-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 30px;
            border-radius: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .close-button:hover {
            color: #333;
        }

        .modal-content h2 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .modal-content h3 {
            color: #764ba2;
            margin: 20px 0 10px 0;
        }

        .modal-content p, .modal-content li {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        
        .modal-input {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ccc;
            margin-top: 10px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s ease;
        }

        .modal-btn.confirm-btn {
            background: #ff4444;
            color: white;
        }
        
        .modal-btn.confirm-btn:hover {
            background: #cc3333;
        }

        .modal-btn.cancel-btn {
            background: #ddd;
            color: #333;
        }

        .modal-btn.cancel-btn:hover {
            background: #ccc;
        }

        .title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .axolotl-emoji {
            font-size: 3rem;
            margin: 0 10px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            max-width: 1000px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: #ff6b6b;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .color-picker-container.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .color-picker {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .color-palette {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .color-btn {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .color-btn:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.8);
        }

        .color-btn.active {
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(14, 30px);
            grid-template-rows: repeat(8, 30px);
            gap: 2px;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 10px;
        }

        .cell {
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 3px;
        }

        .cell:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.3);
        }

        .cell.filled {
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            background: #4ecdc4;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .action-btn:hover {
            background: #45b7aa;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .action-btn.danger {
            background: #ff6b6b;
        }

        .action-btn.danger:hover {
            background: #ff5252;
        }
        
        .action-btn.disabled {
            background-color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .action-btn.disabled:hover {
            background-color: #999;
        }

        .instruction-panel, .memory-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
            width: 100%;
        }

        .instruction-panel.active, .memory-panel.active {
            display: block;
        }
        
        .instruction-panel h3, .memory-panel h3 {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .pattern-display {
            display: grid;
            grid-template-columns: repeat(14, 15px);
            grid-template-rows: repeat(8, 15px);
            gap: 1px;
            justify-content: center;
            margin: 15px 0;
            transition: opacity 0.5s ease;
        }

        .pattern-cell {
            width: 15px;
            height: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
        
        .pattern-cell.highlight-last-placed {
            border: 2px solid red;
            box-shadow: 0 0 5px red;
        }

        .memory-timer {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
            color: #ff6b6b;
        }

        .score {
            text-align: center;
            font-size: 1.2rem;
            margin: 10px 0;
        }
        
        .undo-btn, .redo-btn {
            background-color: #f7a233;
        }
        
        .undo-btn:hover, .redo-btn:hover {
            background-color: #d18a2d;
        }
        
        .instruction-name {
            font-size: 1.5rem;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: repeat(14, 25px);
                grid-template-rows: repeat(8, 25px);
            }
            
            .cell {
                width: 25px;
                height: 25px;
            }
            
            .title {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="info-button" onclick="showModal('info')">‚ÑπÔ∏è</button>
        <h1 class="title">
            <span class="axolotl-emoji">ü¶é</span>
            Game-Axolotl Build
            <span class="axolotl-emoji">ü¶é</span>
        </h1>
    </div>

    <div class="game-container">
        <div class="mode-buttons">
            <button class="mode-btn" id="freestyle-mode-btn" onclick="setMode('freestyle')">üé® Freestyle</button>
            <button class="mode-btn" id="instruction-mode-btn" onclick="setMode('instruction')">üìã Instruction</button>
            <button class="mode-btn" id="memory-mode-btn" onclick="setMode('memory')">üß† Memory</button>
        </div>

        <!-- Global Color Controls -->
        <div class="color-picker-container" id="color-picker-container">
            <label>Colors:</label>
            <div class="color-palette" id="color-palette">
                <div class="color-btn active" style="background-color: #3b82f6;" onclick="selectColor('#3b82f6')" title="Blue"></div>
                <div class="color-btn" style="background-color: #10b981;" onclick="selectColor('#10b981')" title="Green"></div>
                <div class="color-btn" style="background-color: #ef4444;" onclick="selectColor('#ef4444')" title="Red"></div>
                <div class="color-btn" style="background-color: #f97316;" onclick="selectColor('#f97316')" title="Orange"></div>
                <div class="color-btn" style="background-color: #eab308;" onclick="selectColor('#eab308')" title="Yellow"></div>
                <div class="color-btn" style="background-color: #8b5cf6;" onclick="selectColor('#8b5cf6')" title="Purple"></div>
                <div class="color-btn" style="background-color: #ec4899;" onclick="selectColor('#ec4899')" title="Pink"></div>
                <input type="color" class="color-picker" id="freestyleColorPicker" value="#3b82f6" onchange="selectCustomColor(this.value)">
            </div>
        </div>

        <!-- Instruction Panel -->
        <div class="instruction-panel" id="instruction-panel">
            <h3>Follow the Pattern: <span class="instruction-name" id="instruction-name"></span></h3>
            <p>Level: <span id="instruction-level">1</span></p>
            <div class="pattern-display" id="instruction-pattern-display"></div>
            <button class="action-btn" id="new-instruction-btn" onclick="startInstructionChallenge()" style="display:none;">Start New Axolotl</button>
        </div>

        <!-- Memory Panel -->
        <div class="memory-panel" id="memory-panel">
            <h3>Memory Challenge!</h3>
            <p>Level: <span id="memory-level">1</span></p>
            <div class="memory-timer" id="memory-timer"></div>
            <div class="pattern-display" id="memory-pattern-display"></div>
            <div class="score">Score: <span id="memory-score">0</span></div>
            <button class="action-btn" id="start-memory-btn" onclick="startMemoryChallenge()">Start Challenge</button>
        </div>

        <!-- The main grid container, always present but content changes -->
        <div class="grid-container">
            <div class="grid" id="main-grid"></div>
        </div>
        
        <div class="action-buttons" id="main-action-buttons">
            <button class="action-btn undo-btn" id="undo-btn" onclick="undo()" disabled>‚Ü©Ô∏è Undo</button>
            <button class="action-btn redo-btn" id="redo-btn" onclick="redo()" disabled>‚Ü™Ô∏è Redo</button>
            <button class="action-btn" onclick="showModal('clearGrid')">üßπ Clear All</button>
            <button class="action-btn" onclick="fillRandom()">üé≤ Random Fill</button>
            <button class="action-btn" id="save-btn" onclick="savePattern()">üíæ Save Pattern</button>
            <button class="action-btn" id="load-btn" onclick="loadPattern()">üìÅ Load Pattern</button>
            <button class="action-btn danger" id="eraser-btn" onclick="toggleEraser()">üóëÔ∏è <span id="eraser-text">Eraser</span></button>
        </div>
    </div>

    <!-- Custom Modals -->
    <div id="info-modal" class="modal-overlay" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="close-button" onclick="closeModal()">√ó</button>
            <h2 id="modal-title"></h2>
            <div id="modal-body"></div>
            <div id="modal-actions" class="modal-actions"></div>
        </div>
    </div>

    <script>
        let currentMode = 'freestyle';
        let currentColor = '#3b82f6';
        let eraserMode = false;
        let grid = [];
        let instructionPattern = [];
        let instructionPatternIndex = 0;
        let memoryPattern = [];
        let memoryScore = 0;
        let memoryTimer = null;
        let isMemoryStudyPhase = false;
        let instructionLevel = 1;
        let memoryLevel = 1;
        let storagePermission = null;
        let gridHistory = [];
        let redoHistory = [];
        let isDrawing = false;
        
        const ROWS = 8;
        const COLS = 14;

        const INSTRUCTION_PATTERNS = [
            { name: "I-Shape", blocks: [{ r: 2, c: 6, color: '#ec4899' }, { r: 3, c: 6, color: '#ec4899' }, { r: 4, c: 6, color: '#ec4899' }, { r: 5, c: 6, color: '#ec4899' }] },
            { name: "Plus Sign", blocks: [{ r: 3, c: 5, color: '#ec4899' }, { r: 3, c: 6, color: '#ec4899' }, { r: 3, c: 7, color: '#ec4899' }, { r: 4, c: 6, color: '#ec4899' }, { r: 5, c: 6, color: '#ec4899' }] },
            { name: "Heart", blocks: [{ r: 2, c: 5, color: '#ec4899' }, { r: 2, c: 7, color: '#ec4899' }, { r: 3, c: 4, color: '#ec4899' }, { r: 3, c: 6, color: '#ec4899' }, { r: 3, c: 8, color: '#ec4899' }, { r: 4, c: 5, color: '#ec4899' }, { r: 4, c: 7, color: '#ec4899' }, { r: 5, c: 6, color: '#ec4899' }] },
            { name: "Square", blocks: [{ r: 3, c: 5, color: '#3b82f6' }, { r: 3, c: 6, color: '#3b82f6' }, { r: 4, c: 5, color: '#3b82f6' }, { r: 4, c: 6, color: '#3b82f6' }] },
            { name: "Circle", blocks: [{ r: 3, c: 6, color: '#3b82f6' }, { r: 4, c: 5, color: '#3b82f6' }, { r: 4, c: 7, color: '#3b82f6' }, { r: 5, c: 6, color: '#3b82f6' }] },
            { name: "Star", blocks: [{ r: 2, c: 6, color: '#eab308' }, { r: 3, c: 5, color: '#eab308' }, { r: 3, c: 7, color: '#eab308' }, { r: 4, c: 4, color: '#eab308' }, { r: 4, c: 8, color: '#eab308' }, { r: 5, c: 5, color: '#eab308' }, { r: 5, c: 7, color: '#eab308' }, { r: 6, c: 6, color: '#eab308' }] },
            { name: "Tree", blocks: [{ r: 4, c: 6, color: '#10b981' }, { r: 5, c: 5, color: '#10b981' }, { r: 5, c: 6, color: '#10b981' }, { r: 5, c: 7, color: '#10b981' }, { r: 6, c: 6, color: '#10b981' }] },
            { name: "Cross", blocks: [{ r: 3, c: 4, color: '#ef4444' }, { r: 3, c: 5, color: '#ef4444' }, { r: 3, c: 6, color: '#ef4444' }, { r: 3, c: 7, color: '#ef4444' }, { r: 3, c: 8, color: '#ef4444' }, { r: 4, c: 6, color: '#ef4444' }, { r: 5, c: 6, color: '#ef4444' }] },
            { name: "Diamond", blocks: [{ r: 2, c: 6, color: '#8b5cf6' }, { r: 3, c: 5, color: '#8b5cf6' }, { r: 3, c: 7, color: '#8b5cf6' }, { r: 4, c: 6, color: '#8b5cf6' }] },
            { name: "Fish", blocks: [{ r: 4, c: 4, color: '#f97316' }, { r: 4, c: 5, color: '#f97316' }, { r: 4, c: 6, color: '#f97316' }, { r: 3, c: 7, color: '#f97316' }, { r: 5, c: 7, color: '#f97316' }, { r: 4, c: 8, color: '#f97316' }] },
            { name: "Cloud", blocks: [{ r: 2, c: 5, color: '#3b82f6' }, { r: 2, c: 6, color: '#3b82f6' }, { r: 2, c: 7, color: '#3b82f6' }, { r: 3, c: 4, color: '#3b82f6' }, { r: 3, c: 8, color: '#3b82f6' }, { r: 4, c: 5, color: '#3b82f6' }, { r: 4, c: 6, color: '#3b82f6' }, { r: 4, c: 7, color: '#3b82f6' }] },
            { name: "Boat", blocks: [{ r: 5, c: 3, color: '#3b82f6' }, { r: 5, c: 4, color: '#3b82f6' }, { r: 5, c: 5, color: '#3b82f6' }, { r: 5, c: 6, color: '#3b82f6' }, { r: 5, c: 7, color: '#3b82f6' }, { r: 5, c: 8, color: '#3b82f6' }, { r: 3, c: 5, color: '#eab308' }, { r: 4, c: 5, color: '#eab308' }] },
            { name: "Ghost", blocks: [{ r: 2, c: 5, color: '#ddd' }, { r: 2, c: 6, color: '#ddd' }, { r: 2, c: 7, color: '#ddd' }, { r: 3, c: 4, color: '#ddd' }, { r: 3, c: 8, color: '#ddd' }, { r: 4, c: 4, color: '#ddd' }, { r: 4, c: 8, color: '#ddd' }, { r: 5, c: 5, color: '#ddd' }, { r: 5, c: 7, color: '#ddd' }] },
            { name: "House", blocks: [{ r: 3, c: 5, color: '#ef4444' }, { r: 3, c: 6, color: '#ef4444' }, { r: 3, c: 7, color: '#ef4444' }, { r: 4, c: 5, color: '#f97316' }, { r: 4, c: 7, color: '#f97316' }, { r: 5, c: 5, color: '#f97316' }, { r: 5, c: 6, color: '#f97316' }, { r: 5, c: 7, color: '#f97316' }] },
            { name: "Butterfly", blocks: [{ r: 2, c: 4, color: '#ec4899' }, { r: 2, c: 8, color: '#ec4899' }, { r: 3, c: 5, color: '#8b5cf6' }, { r: 3, c: 7, color: '#8b5cf6' }, { r: 4, c: 6, color: '#8b5cf6' }, { r: 5, c: 4, color: '#ec4899' }, { r: 5, c: 8, color: '#ec4899' }] },
            { name: "Mushroom", blocks: [{ r: 3, c: 5, color: '#ef4444' }, { r: 3, c: 6, color: '#ef4444' }, { r: 3, c: 7, color: '#ef4444' }, { r: 4, c: 4, color: '#ef4444' }, { r: 4, c: 8, color: '#ef4444' }, { r: 5, c: 6, color: '#ddd' }, { r: 6, c: 6, color: '#ddd' }] },
            { name: "Smiley Face", blocks: [{ r: 3, c: 5, color: '#eab308' }, { r: 3, c: 7, color: '#eab308' }, { r: 4, c: 4, color: '#eab308' }, { r: 4, c: 8, color: '#eab308' }, { r: 5, c: 5, color: '#eab308' }, { r: 5, c: 6, color: '#eab308' }, { r: 5, c: 7, color: '#eab308' }] },
            { name: "Checkerboard", blocks: [{ r: 2, c: 5, color: '#3b82f6' }, { r: 2, c: 6, color: '#ec4899' }, { r: 3, c: 5, color: '#ec4899' }, { r: 3, c: 6, color: '#3b82f6' }, { r: 4, c: 5, color: '#3b82f6' }, { r: 4, c: 6, color: '#ec4899' }, { r: 5, c: 5, color: '#ec4899' }, { r: 5, c: 6, color: '#3b82f6' }] },
            { name: "Car", blocks: [{ r: 4, c: 3, color: '#ef4444' }, { r: 4, c: 4, color: '#ef4444' }, { r: 4, c: 5, color: '#ef4444' }, { r: 4, c: 6, color: '#ef4444' }, { r: 5, c: 3, color: '#ef4444' }, { r: 5, c: 6, color: '#ef4444' }, { r: 6, c: 4, color: '#ddd' }, { r: 6, c: 5, color: '#ddd' }] },
            { name: "Arrow", blocks: [{ r: 4, c: 5, color: '#10b981' }, { r: 4, c: 6, color: '#10b981' }, { r: 4, c: 7, color: '#10b981' }, { r: 3, c: 6, color: '#10b981' }, { r: 5, c: 6, color: '#10b981' }] }
        ];
        
        const PRESET_COLORS = ['#3b82f6', '#10b981', '#ef4444', '#f97316', '#eab308', '#8b5cf6', '#ec4899'];
        
        window.onload = () => {
            initGame();
        };

        function initGame() {
            createGrid();
            setMode('freestyle');
            requestStoragePermission();
            updateColorPicker();
            updateUndoRedoButtons();
        }

        function requestStoragePermission() {
            const savedPermission = localStorage.getItem('axolotlStoragePermission');
            if (savedPermission === 'granted') {
                storagePermission = true;
            } else if (savedPermission === 'denied') {
                storagePermission = false;
            } else {
                showModal('storagePermission');
            }
            updateSaveLoadButtons();
        }
        
        function createGrid() {
            const mainGrid = document.getElementById('main-grid');
            mainGrid.innerHTML = '';
            grid = [];

            for (let row = 0; row < ROWS; row++) {
                grid[row] = [];
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    cell.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        isDrawing = true;
                        
                        if (currentMode === 'instruction') {
                            checkInstructionStep(row, col);
                        } else {
                            saveGridState();
                            handleCellInteraction(row, col);
                            redoHistory = [];
                            updateUndoRedoButtons();
                        }
                    });
                    cell.addEventListener('mouseover', () => {
                        if (isDrawing && currentMode === 'freestyle') {
                            handleCellInteraction(row, col);
                        }
                    });
                    cell.addEventListener('mouseup', () => {
                        isDrawing = false;
                    });
                    cell.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        isDrawing = true;
                        if (currentMode === 'instruction') {
                            checkInstructionStep(row, col);
                        } else {
                            saveGridState();
                            handleCellInteraction(row, col);
                            redoHistory = [];
                            updateUndoRedoButtons();
                        }
                    }, { passive: false });
                    cell.addEventListener('touchmove', (e) => {
                        if (isDrawing && currentMode === 'freestyle') {
                            const touch = e.touches[0];
                            const target = document.elementFromPoint(touch.clientX, touch.clientY);
                            if (target && target.classList.contains('cell')) {
                                const targetRow = parseInt(target.dataset.row);
                                const targetCol = parseInt(target.dataset.col);
                                handleCellInteraction(targetRow, targetCol);
                            }
                        }
                    }, { passive: false });
                    cell.addEventListener('touchend', () => {
                        isDrawing = false;
                    });
                    
                    mainGrid.appendChild(cell);
                    grid[row][col] = { color: null, element: cell };
                }
            }
            
            document.addEventListener('mouseup', () => isDrawing = false);
            document.addEventListener('touchend', () => isDrawing = false);
        }

        function handleCellInteraction(row, col) {
            const cell = grid[row][col];
            
            if (currentMode === 'memory' && isMemoryStudyPhase) {
                return;
            }
            
            if (currentMode !== 'freestyle') {
                if (!PRESET_COLORS.includes(currentColor) && !eraserMode) {
                    return;
                }
            }
            
            const prevColor = cell.color;
            if (eraserMode && prevColor !== null) {
                cell.color = null;
                cell.element.style.backgroundColor = '';
                cell.element.classList.remove('filled');
            } else if (!eraserMode && prevColor !== currentColor) {
                cell.color = currentColor;
                cell.element.style.backgroundColor = currentColor;
                cell.element.classList.add('filled');
            } else {
                return;
            }

            if (currentMode === 'memory' && !isMemoryStudyPhase) {
                checkMemoryCompletion();
            }
        }
        
        function saveGridState() {
            const state = grid.map(row => row.map(cell => cell.color));
            gridHistory.push(state);
            if (gridHistory.length > 20) {
                gridHistory.shift();
            }
            updateUndoRedoButtons();
        }

        function undo() {
            if (gridHistory.length > 0) {
                redoHistory.push(grid.map(row => row.map(cell => cell.color)));
                const previousState = gridHistory.pop();
                applyGridState(previousState);
                updateUndoRedoButtons();
            }
        }
        
        function redo() {
            if (redoHistory.length > 0) {
                gridHistory.push(grid.map(row => row.map(cell => cell.color)));
                const nextState = redoHistory.pop();
                applyGridState(nextState);
                updateUndoRedoButtons();
            }
        }
        
        function applyGridState(state) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const color = state[r][c];
                    const cell = grid[r][c];
                    cell.color = color;
                    if (color) {
                        cell.element.style.backgroundColor = color;
                        cell.element.classList.add('filled');
                    } else {
                        cell.element.style.backgroundColor = '';
                        cell.element.classList.remove('filled');
                    }
                }
            }
        }

        function updateUndoRedoButtons() {
            document.getElementById('undo-btn').disabled = gridHistory.length === 0;
            document.getElementById('redo-btn').disabled = redoHistory.length === 0;
        }

        function selectColor(color) {
            currentColor = color;
            eraserMode = false;
            updateEraserButton();
            
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll(`.color-btn[style*="${color}"]`).forEach(btn => btn.classList.add('active'));
            
            document.getElementById('freestyleColorPicker').value = color;
        }

        function selectCustomColor(color) {
            currentColor = color;
            eraserMode = false;
            updateEraserButton();
            
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
        }

        function setMode(mode) {
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${mode}-mode-btn`).classList.add('active');
            
            document.getElementById('instruction-panel').classList.remove('active');
            document.getElementById('memory-panel').classList.remove('active');
            
            currentMode = mode;
            clearGrid(false);
            
            if (mode === 'instruction') {
                document.getElementById('instruction-panel').classList.add('active');
                startInstructionChallenge();
            } else if (mode === 'memory') {
                document.getElementById('memory-panel').classList.add('active');
                updateLevelDisplay('memory');
                document.getElementById('start-memory-btn').style.display = 'block';
                document.getElementById('memory-timer').textContent = '';
                document.getElementById('memory-pattern-display').innerHTML = '';
            }
            
            gridHistory = [];
            redoHistory = [];
            updateUndoRedoButtons();
        }

        function updateLevelDisplay(mode) {
            const level = mode === 'instruction' ? instructionLevel : memoryLevel;
            const levelElement = document.getElementById(`${mode}-level`);
            if (levelElement) {
                 levelElement.textContent = level;
            }
        }

        function updateColorPicker() {
            const freestylePicker = document.getElementById('freestyleColorPicker');
            freestylePicker.addEventListener('change', (e) => selectCustomColor(e.target.value));
        }

        function clearGrid(prompt = true) {
            if (prompt) {
                showModal('clearGrid');
                return;
            }
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = grid[row][col];
                    cell.color = null;
                    cell.element.style.backgroundColor = '';
                    cell.element.classList.remove('filled');
                }
            }
            gridHistory = [];
            redoHistory = [];
            updateUndoRedoButtons();
        }

        function fillRandom() {
            showModal('fillRandom', () => {
                clearGrid(false);
                saveGridState();
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7aa', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
                
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        if (Math.random() > 0.7) {
                            const randomColor = colors[Math.floor(Math.random() * colors.length)];
                            const cell = grid[row][col];
                            cell.color = randomColor;
                            cell.element.style.backgroundColor = randomColor;
                            cell.element.classList.add('filled');
                        }
                    }
                }
            });
        }

        function toggleEraser() {
            eraserMode = !eraserMode;
            updateEraserButton();
        }

        function updateEraserButton() {
            const eraserText = document.getElementById('eraser-text');
            const eraserBtn = document.getElementById('eraser-btn');
            
            if (eraserMode) {
                eraserText.textContent = 'Drawing';
                eraserBtn.style.background = '#4ecdc4';
            } else {
                eraserText.textContent = 'Eraser';
                eraserBtn.style.background = '#ff6b6b';
            }
        }

        function startInstructionChallenge() {
            clearGrid(false);
            instructionPatternIndex = 0;
            
            const savedPattern = localStorage.getItem('axolotlInstruction');
            if (savedPattern) {
                const savedData = JSON.parse(savedPattern);
                instructionLevel = savedData.level;
            } else {
                instructionLevel = 1;
            }
            
            document.getElementById('new-instruction-btn').style.display = 'none';
            loadInstructionLevel();
        }
        
        function loadInstructionLevel() {
            if (instructionLevel > INSTRUCTION_PATTERNS.length) {
                showModal('levelUp', { message: 'You have completed all instruction levels! Well done! üéâ' });
                document.getElementById('new-instruction-btn').style.display = 'inline-block';
                return;
            }
            
            const patternData = INSTRUCTION_PATTERNS[instructionLevel - 1];
            instructionPattern = patternData.blocks;
            instructionPatternIndex = 0;
            updateLevelDisplay('instruction');
            document.getElementById('instruction-name').textContent = patternData.name;
            updateInstructionDisplay();
        }
        
        function updateInstructionDisplay() {
            const patternDisplay = document.getElementById('instruction-pattern-display');
            patternDisplay.innerHTML = '';
            
            const currentPattern = INSTRUCTION_PATTERNS[instructionLevel - 1].blocks;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'pattern-cell';
                    
                    const blockIndex = currentPattern.findIndex(b => b.r === row && b.c === col);
                    
                    if (blockIndex !== -1) {
                        // Display previously placed blocks
                        if (blockIndex < instructionPatternIndex) {
                            cell.style.backgroundColor = currentPattern[blockIndex].color;
                        }
                        // Display and highlight the current block to be placed
                        else if (blockIndex === instructionPatternIndex) {
                            cell.style.backgroundColor = currentPattern[blockIndex].color;
                            cell.classList.add('highlight-last-placed');
                        }
                    }
                    
                    patternDisplay.appendChild(cell);
                }
            }
        }

        function checkInstructionStep(row, col) {
            // Do not proceed if all blocks are already placed.
            if (instructionPatternIndex >= INSTRUCTION_PATTERNS[instructionLevel - 1].blocks.length) {
                return;
            }

            const currentPattern = INSTRUCTION_PATTERNS[instructionLevel - 1].blocks;
            const nextBlock = currentPattern[instructionPatternIndex];
            
            // Check if the player's click matches the next required block.
            if (row === nextBlock.r && col === nextBlock.c && currentColor === nextBlock.color) {
                saveGridState();
                const cell = grid[row][col];
                cell.color = currentColor;
                cell.element.style.backgroundColor = currentColor;
                cell.element.classList.add('filled');

                // Advance to the next step.
                instructionPatternIndex++;
                
                // Update the visual display to show the newly placed block.
                updateInstructionDisplay();

                // Check for level completion.
                if (instructionPatternIndex >= currentPattern.length) {
                    instructionLevel++;
                    setTimeout(() => {
                        showModal('levelUp', { message: `Level ${instructionLevel - 1} completed! Onto the next one! üéâ` });
                        if (instructionLevel <= INSTRUCTION_PATTERNS.length) {
                            loadInstructionLevel();
                        } else {
                            document.getElementById('new-instruction-btn').style.display = 'inline-block';
                            showModal('levelUp', { message: 'You have completed all instruction levels! Well done! üéâ' });
                        }
                    }, 500);
                }
            }
        }

        function startMemoryChallenge() {
            document.getElementById('start-memory-btn').style.display = 'none';
            generateMemoryPattern();
            showMemoryPattern();
            startMemoryTimer();
        }

        function generateMemoryPattern() {
            memoryPattern = [];
            const colors = PRESET_COLORS;
            
            const numBlocks = memoryLevel;
            
            for (let i = 0; i < numBlocks; i++) {
                const randomRow = Math.floor(Math.random() * ROWS);
                const randomCol = Math.floor(Math.random() * COLS);
                const randomColor = colors[Math.floor(Math.random() * Math.min(colors.length, 2 + memoryLevel))];
                
                if (!memoryPattern[randomRow]) {
                    memoryPattern[randomRow] = [];
                }
                memoryPattern[randomRow][randomCol] = randomColor;
            }
        }

        function showMemoryPattern() {
            const patternDisplay = document.getElementById('memory-pattern-display');
            patternDisplay.innerHTML = '';
            
            for (let row = 0; row < ROWS; row++) {
                if (!memoryPattern[row]) memoryPattern[row] = [];
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'pattern-cell';
                    if (memoryPattern[row][col]) {
                        cell.style.backgroundColor = memoryPattern[row][col];
                    }
                    patternDisplay.appendChild(cell);
                }
            }
            
            isMemoryStudyPhase = true;
            patternDisplay.style.opacity = '1';
        }

        function startMemoryTimer() {
            const timeLimit = Math.max(5, 10 - Math.floor(memoryLevel / 2));
            let timeLeft = timeLimit;
            const timerElement = document.getElementById('memory-timer');
            
            memoryTimer = setInterval(() => {
                timerElement.textContent = `Time left: ${timeLeft}s`;
                timeLeft--;
                
                if (timeLeft < 0) {
                    clearInterval(memoryTimer);
                    hideMemoryPattern();
                    timerElement.textContent = 'Recreate it!';
                    isMemoryStudyPhase = false;
                    clearGrid(false);
                }
            }, 1000);
        }

        function hideMemoryPattern() {
            document.getElementById('memory-pattern-display').style.opacity = '0';
        }

        function checkMemoryCompletion() {
            let correctCells = 0;
            let totalPatternCells = 0;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const gridCellColor = grid[row][col].color;
                    const patternCellColor = memoryPattern[row][col];
                    
                    if (patternCellColor) {
                        totalPatternCells++;
                        if (gridCellColor === patternCellColor) {
                            correctCells++;
                        }
                    }
                }
            }
            
            const accuracy = totalPatternCells > 0 ? (correctCells / totalPatternCells) : 0;

            if (accuracy >= 1) {
                memoryScore += 10;
                memoryLevel++;
                updateLevelDisplay('memory');
                setTimeout(() => {
                    showModal('levelUp', { message: `Perfect memory! Level ${memoryLevel - 1} completed! +10 points!` });
                    updateMemoryScore();
                    startMemoryChallenge();
                }, 100);
            } else if (accuracy >= 0.8) {
                memoryScore += 5;
                setTimeout(() => {
                    showModal('retry', { message: `Good memory! ${Math.floor(accuracy * 100)}% correct. +5 points! Try again to advance!` });
                    updateMemoryScore();
                    startMemoryChallenge();
                }, 100);
            }
        }

        function updateMemoryScore() {
            document.getElementById('memory-score').textContent = memoryScore;
        }

        function savePattern() {
            if (!storagePermission) {
                showModal('permissionDenied');
                return;
            }
            
            let saveKey;
            let saveData = {};
            switch(currentMode) {
                case 'instruction':
                    saveKey = 'axolotlInstruction';
                    saveData = {
                        level: instructionLevel,
                        pattern: grid.map(row => row.map(cell => cell.color))
                    };
                    break;
                case 'memory':
                    saveKey = 'axolotlMemory';
                    saveData = {
                        level: memoryLevel,
                        score: memoryScore,
                        pattern: grid.map(row => row.map(cell => cell.color))
                    };
                    break;
                default:
                    saveKey = 'axolotlFreestyle';
                    saveData = {
                        pattern: grid.map(row => row.map(cell => cell.color))
                    };
            }
            
            localStorage.setItem(saveKey, JSON.stringify(saveData));
            showModal('saveSuccess');
        }

        function loadPattern() {
            if (!storagePermission) {
                showModal('permissionDenied');
                return;
            }
            
            let saveKey;
            switch(currentMode) {
                case 'instruction': saveKey = 'axolotlInstruction'; break;
                case 'memory': saveKey = 'axolotlMemory'; break;
                default: saveKey = 'axolotlFreestyle';
            }
            
            const savedPattern = localStorage.getItem(saveKey);
            
            if (savedPattern) {
                showModal('loadPattern', () => {
                    const savedData = JSON.parse(savedPattern);
                    
                    clearGrid(false);
                    
                    for (let row = 0; row < ROWS; row++) {
                        for (let col = 0; col < COLS; col++) {
                            const cell = grid[row][col];
                            const color = savedData.pattern[row][col];
                            
                            if (color) {
                                cell.color = color;
                                cell.element.style.backgroundColor = color;
                                cell.element.classList.add('filled');
                            }
                        }
                    }
                    
                    if (currentMode === 'instruction') {
                        instructionLevel = savedData.level;
                        updateLevelDisplay('instruction');
                        updateInstructionDisplay();
                    } else if (currentMode === 'memory') {
                        memoryLevel = savedData.level;
                        memoryScore = savedData.score;
                        updateLevelDisplay('memory');
                        updateMemoryScore();
                    }
                    
                    showModal('loadSuccess');
                });
            } else {
                showModal('noSaveFound');
            }
        }
        
        function updateSaveLoadButtons() {
            const saveBtn = document.getElementById('save-btn');
            const loadBtn = document.getElementById('load-btn');
            
            if (storagePermission) {
                saveBtn.classList.remove('disabled');
                loadBtn.classList.remove('disabled');
                saveBtn.disabled = false;
                loadBtn.disabled = false;
            } else {
                saveBtn.classList.add('disabled');
                loadBtn.classList.add('disabled');
                saveBtn.disabled = true;
                loadBtn.disabled = true;
            }
        }

        let currentModalCallback = null;

        function showModal(type, callback = null) {
            const modalOverlay = document.getElementById('info-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            const modalActions = document.getElementById('modal-actions');
            
            modalTitle.textContent = '';
            modalBody.innerHTML = '';
            modalActions.innerHTML = '';
            
            currentModalCallback = callback;
            
            switch (type) {
                case 'info':
                    modalTitle.textContent = 'ü¶é Game-Axolotl Build - How to Play';
                    modalBody.innerHTML = `
                        <h3>üé® Freestyle Mode</h3>
                        <p>Create any pattern you want! Use the color palette to select colors and click on the grid to paint. You can also click and drag to color multiple cells at once.</p>
                        <h3>üìã Instruction Mode</h3>
                        <p>Follow the patterns shown on each level. The last block you placed is outlined in red.</p>
                        <h3>üß† Memory Mode</h3>
                        <p>Test your memory skills! Study the pattern, then recreate it from memory. The score tracks your progress.</p>
                        <h3>üíæ Save System Status</h3>
                        <p>Saving is currently **${storagePermission ? 'enabled' : 'disabled'}**. Your patterns are saved locally to your browser's storage.</p>
                        ${storagePermission !== null ? `
                            <div style="text-align:center; padding: 10px; background: rgba(255,255,255,0.1); border-radius:10px; margin-top:20px;">
                                <button class="action-btn" onclick="showModal('storagePermission')">Change My Mind</button>
                            </div>
                        ` : ''}
                        <button class="action-btn danger" style="background-color: #ff6b6b; margin-top: 20px;" onclick="showModal('deleteAll')">üóëÔ∏è Delete All Progress</button>
                    `;
                    break;
                case 'storagePermission':
                    modalTitle.textContent = 'Welcome! ü¶é';
                    modalBody.innerHTML = '<p>This game can save your patterns to your device for later use. Would you like to allow saving patterns to your browser storage?</p>';
                    modalActions.innerHTML = `
                        <button class="modal-btn confirm-btn" onclick="grantStoragePermission(true)">Yes, Allow</button>
                        <button class="modal-btn cancel-btn" onclick="grantStoragePermission(false)">No, Deny</button>
                    `;
                    break;
                case 'clearGrid':
                    modalTitle.textContent = 'Clear All?';
                    modalBody.innerHTML = '<p>Are you sure you want to clear the entire board? This action cannot be undone.</p>';
                    modalActions.innerHTML = `
                        <button class="modal-btn confirm-btn" onclick="clearGrid(false); closeModal();">Yes, Clear</button>
                        <button class="modal-btn cancel-btn" onclick="closeModal()">Cancel</button>
                    `;
                    break;
                case 'fillRandom':
                    modalTitle.textContent = 'Random Fill?';
                    modalBody.innerHTML = '<p>Are you sure you want to clear the board and create a random pattern?</p>';
                    modalActions.innerHTML = `
                        <button class="modal-btn confirm-btn" onclick="if (currentModalCallback) currentModalCallback(); closeModal();">Yes, Fill Randomly</button>
                        <button class="modal-btn cancel-btn" onclick="closeModal()">Cancel</button>
                    `;
                    break;
                case 'saveSuccess':
                    modalTitle.textContent = 'Pattern Saved!';
                    modalBody.innerHTML = '<p>Your pattern has been saved successfully!</p>';
                    modalActions.innerHTML = `<button class="modal-btn cancel-btn" onclick="closeModal()">OK</button>`;
                    break;
                case 'loadPattern':
                    modalTitle.textContent = 'Load Pattern?';
                    modalBody.innerHTML = '<p>This will clear your current board and replace it with the saved pattern. Continue?</p>';
                    modalActions.innerHTML = `
                        <button class="modal-btn confirm-btn" onclick="if (currentModalCallback) currentModalCallback(); closeModal();">Yes, Load</button>
                        <button class="modal-btn cancel-btn" onclick="closeModal()">Cancel</button>
                    `;
                    break;
                case 'loadSuccess':
                    modalTitle.textContent = 'Pattern Loaded!';
                    modalBody.innerHTML = '<p>Your saved pattern has been loaded successfully!</p>';
                    modalActions.innerHTML = `<button class="modal-btn cancel-btn" onclick="closeModal()">OK</button>`;
                    break;
                case 'noSaveFound':
                    modalTitle.textContent = 'No Save Found';
                    modalBody.innerHTML = '<p>No saved pattern found for this mode. Use the Save Pattern button first!</p>';
                    modalActions.innerHTML = `<button class="modal-btn cancel-btn" onclick="closeModal()">OK</button>`;
                    break;
                case 'permissionDenied':
                    modalTitle.textContent = 'Saving Disabled';
                    modalBody.innerHTML = '<p>You have not granted permission to use local storage. Save/Load buttons are now disabled. You can re-enable them from the Info modal.</p>';
                    modalActions.innerHTML = `<button class="modal-btn cancel-btn" onclick="closeModal()">OK</button>`;
                    break;
                case 'deleteAll':
                    modalTitle.textContent = 'Delete All Progress?';
                    modalBody.innerHTML = `
                        <p>Are you sure you want to delete ALL your saved progress? This will remove all saved patterns and reset your levels. This action cannot be undone!</p>
                        <p>To confirm, please type <strong>"Delete My Progress"</strong> exactly below.</p>
                        <input type="text" id="delete-confirm-input" class="modal-input" placeholder="Delete My Progress">
                    `;
                    modalActions.innerHTML = `
                        <button class="modal-btn confirm-btn" onclick="confirmDeleteAllProgress()">Yes, Delete All</button>
                        <button class="modal-btn cancel-btn" onclick="closeModal()">Cancel</button>
                    `;
                    break;
                case 'confirmDeleteAll':
                    modalTitle.textContent = 'Confirm Deletion';
                    modalBody.innerHTML = `<p>Are you absolutely sure you want to proceed with deleting all your progress? This is permanent.</p>`;
                    modalActions.innerHTML = `
                        <button class="modal-btn confirm-btn" onclick="deleteAllProgress()">Yes, I'm Sure</button>
                        <button class="modal-btn cancel-btn" onclick="closeModal()">Cancel</button>
                    `;
                    break;
                case 'levelUp':
                    modalTitle.textContent = callback.message;
                    modalBody.innerHTML = '';
                    modalActions.innerHTML = `<button class="modal-btn cancel-btn" onclick="closeModal()">OK</button>`;
                    break;
                case 'retry':
                    modalTitle.textContent = 'Try Again!';
                    modalBody.innerHTML = `<p>${callback.message}</p>`;
                    modalActions.innerHTML = `<button class="modal-btn cancel-btn" onclick="closeModal()">OK</button>`;
                    break;
            }
            
            modalOverlay.classList.add('active');
        }

        function closeModal() {
            const modalOverlay = document.getElementById('info-modal');
            modalOverlay.classList.remove('active');
            currentModalCallback = null;
        }

        function grantStoragePermission(granted) {
            storagePermission = granted;
            localStorage.setItem('axolotlStoragePermission', granted ? 'granted' : 'denied');
            updateSaveLoadButtons();
            closeModal();
            if (granted) {
                showModal('info');
            } else {
                showModal('permissionDenied');
            }
        }

        function confirmDeleteAllProgress() {
            const input = document.getElementById('delete-confirm-input');
            if (input.value === 'Delete My Progress') {
                showModal('confirmDeleteAll');
            } else {
                showModal('retry', { message: 'Incorrect confirmation phrase. Please try again.' });
            }
        }

        function deleteAllProgress() {
            localStorage.clear();
            instructionLevel = 1;
            memoryLevel = 1;
            memoryScore = 0;
            
            clearGrid(false);
            updateMemoryScore();
            setMode('freestyle');
            
            showModal('levelUp', { message: 'All progress has been deleted.' });
        }

    </script>
</body>
</html>
